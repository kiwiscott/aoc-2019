#[derive(Debug, Clone, Eq, PartialEq)]
pub enum MachineState {
    NotStarted,
    Running,
    Completed,
    Failed(String),
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum OpCode {
    Multiplication(Mode, Mode, Mode),
    Addition(Mode, Mode, Mode),
    Input(Mode),
    Output(Mode),
    Complete,
    JumpIfTrue(Mode, Mode),
    JumpIfFalse(Mode, Mode),
    LessThan(Mode, Mode, Mode),
    Equals(Mode, Mode, Mode),
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Mode {
    Position(usize),
    Immediate(i32),
    None,
}
pub struct Machine {
    instructions: Vec<i32>,
    original_instructions: Vec<i32>,

    state: MachineState,
}
impl Machine {
    pub fn new(instructions: &[i32]) -> Self {
        let v = instructions.to_vec();
        Machine {
            original_instructions: v.clone(),
            instructions: v.clone(),

            state: MachineState::NotStarted,
        }
    }
    pub fn value_at(&self, at: usize) -> i32 {
        self.instructions[at]
    }

    fn get_parameter(&self, n_param: i32, position_index: usize) -> Mode {
        if self.instructions.get(position_index) == None {
            Mode::None
        } else {
            match n_param {
                1 => Mode::Immediate(self.instructions[position_index]),
                _ => Mode::Position(self.instructions[position_index] as usize),
            }
        }
    }

    fn instruction(&self, position_index: usize) -> OpCode {
        let n = self.instructions[position_index];
        println!("Executing Instruction: {:?}", n);
        let p1 = self.get_parameter((n / 100) % 10, position_index + 1);
        let p2 = self.get_parameter(n / 1000, position_index + 2);
        let p3 = self.get_parameter(n / 10000, position_index + 3);
        let opcode = (((n / 10) % 10) * 10) + (n % 10);

        let op = match opcode {
            1 => OpCode::Addition(p1, p2, self.ensure_position(p3)),
            2 => OpCode::Multiplication(p1, p2, self.ensure_position(p3)),
            3 => OpCode::Input(p1),
            4 => OpCode::Output(p1),
            5 => OpCode::JumpIfTrue(p1, self.ensure_position(p2)),
            6 => OpCode::JumpIfFalse(p1, self.ensure_position(p2)),
            7 => OpCode::LessThan(p1, p2, self.ensure_position(p3)),
            8 => OpCode::Equals(p1, p2, self.ensure_position(p3)),
            99 => OpCode::Complete,
            _ => panic!("Unknown Op Code: {:?}", n),
        };
        
        op
    }
    fn ensure_position(&self, m: Mode) -> Mode {
        if let Mode::Immediate(n) = m {
            return Mode::Position(n as usize);
        }
        return m;
    }

    pub fn process(&mut self) -> Option<MachineState> {
        let empty: Vec<i32> = vec![];
        self.process_with_input(&empty)
    }
    fn mode_value(&self, m: Mode) -> i32 {
        let x = match m {
            Mode::Immediate(n) => n,
            Mode::Position(index) => self.instructions[index as usize],
            Mode::None => unreachable!(),
        };

        println!("{:?} : {:?}", m, x);

        x
    }

    pub fn process_with_input(&mut self, inputs: &[i32]) -> Option<MachineState> {
        self.instructions = self.original_instructions.clone();

        let mut instruction_pointer: usize = 0;
        let mut all_inputs: Vec<i32> = vec![];
        for i in inputs {
            all_inputs.push(*i);
        }
        let mut input = all_inputs.iter();

        self.state = MachineState::Running;

        loop {
            let mut next_step = 4;
            // println!("Processing -- {:?}", self.instructions);

            match self.instruction(instruction_pointer) {
                OpCode::Multiplication(p1, p2, Mode::Position(store)) => {
                    let x = self.mode_value(p1);
                    let y = self.mode_value(p2);

                    self.instructions[store] = x * y;
                }
                OpCode::Addition(p1, p2, Mode::Position(store)) => {
                    let x = self.mode_value(p1);
                    let y = self.mode_value(p2);
                    self.instructions[store] = x + y;
                }
                OpCode::Input(Mode::Position(store)) => {
                    next_step = 2;
                    match input.next() {
                        Some(n) => self.instructions[store as usize] = *n,
                        _ => {
                            return Some(MachineState::Failed(format!(
                                "Failed to execute Operation code at index [{:?}]",
                                instruction_pointer
                            )));
                        }
                    }
                }
                OpCode::Output(p1) => {
                    next_step = 2;
                    let x = self.mode_value(p1);
                    println!("Output Param: {:?}", x);
                }
                OpCode::JumpIfTrue(p1, Mode::Position(jump_to)) => {
                    let x = self.mode_value(p1);
                    if x != 0 {
                        instruction_pointer = jump_to;
                        next_step = 0;
                    } else {
                        next_step = 3;
                    }
                }

                //The problem here is that the position parameters are always supposed to be
                //set for the placement but we are passing immediate nodes in our tests
                // Sort of sucks
                OpCode::JumpIfFalse(p1, Mode::Position(jump_to)) => {
                    let x = self.mode_value(p1);
                    if x == 0 {
                        instruction_pointer = jump_to;
                        next_step = 0;
                    } else {
                        next_step = 3;
                    }
                }
                OpCode::LessThan(p1, p2, Mode::Position(store)) => {
                    let x = self.mode_value(p1);
                    let y = self.mode_value(p2);
                    let r = if x < y { 1 } else { 0 };
                    self.instructions[store] = r;
                }
                OpCode::Equals(p1, p2, Mode::Position(store)) => {
                    let x = self.mode_value(p1);
                    let y = self.mode_value(p2);
                    let r = if x == y { 1 } else { 0 };
                    self.instructions[store] = r;
                }
                OpCode::Complete => {
                    self.state = MachineState::Completed;
                    return Some(MachineState::Completed);
                }
                _ => {
                    return Some(MachineState::Failed(format!(
                        "Failed to execute Operation code at index [{:?}]",
                        instruction_pointer
                    )));
                }
            }
            instruction_pointer += next_step;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn day5_larger_example() {
        //3,3,1108,-1,8,3,4,3,99 - Using immediate mode,
        //consider whether the input is equal to 8;
        //output 1 (if it is) or 0 (if it is not).
        let data = vec![
            3, 21, 1008, 21, 8, 20, 1005, 20, 22, 107, 8, 21, 20, 1006, 20, 31, 1106, 0, 36, 98, 0,
            0, 1002, 21, 125, 20, 4, 20, 1105, 1, 46, 104, 999, 1105, 1, 46, 1101, 1000, 1, 20, 4,
            20, 1105, 1, 46, 98, 99,
        ];

        let mut m = Machine::new(&data);
        m.process_with_input(&[7]);

        //m.process_with_input(&[8]);

        //m.process_with_input(&[20]);

        println!("{:?}", m.instructions);
        assert_eq!(0, m.value_at(3));
    }
    #[test]
    fn day5_immediate_mode_tests() {
        //3,3,1108,-1,8,3,4,3,99 - Using immediate mode,
        //consider whether the input is equal to 8;
        //output 1 (if it is) or 0 (if it is not).
        let data = vec![3, 3, 1108, -1, 8, 3, 4, 3, 99];
        let mut m = Machine::new(&data);
        m.process_with_input(&[8]);

        println!("{:?}", m.instructions);
        assert_eq!(1, m.value_at(3));

        m.process_with_input(&[7]);
        assert_eq!(0, m.value_at(3));

        //3,3,1107,-1,8,3,4,3,99 - Using immediate mode, consider whether
        //the input is less than 8; output 1 (if it is) or 0 (if it is not).
        let data = vec![3, 3, 1107, -1, 8, 3, 4, 3, 99];
        let mut m = Machine::new(&data);
        m.process_with_input(&[7]);
        assert_eq!(1, m.value_at(3));

        m.process_with_input(&[9]);
        assert_eq!(0, m.value_at(3));
    }

    #[test]
    fn day5_sample_tests() {
        //3,9,8,9,10,9,4,9,99,-1,8 - Using position mode, consider whether
        // the input is equal to 8; output 1 (if it is) or 0 (if it is not).
        let data = vec![3, 9, 8, 9, 10, 9, 4, 9, 99, -1, 8];
        let mut m = Machine::new(&data);

        m.process_with_input(&[8]);
        assert_eq!(1, m.value_at(9));

        m.process_with_input(&[7]);
        assert_eq!(0, m.value_at(9));

        // 3,9,7,9,10,9,4,9,99,-1,8 - Use input is less than 8;
        //output 1 (if it is) or 0 (if it is not).
        let data = vec![3, 9, 7, 9, 10, 9, 4, 9, 99, -1, 8];
        let mut m = Machine::new(&data);

        m.process_with_input(&[7]);
        assert_eq!(1, m.value_at(9));

        m.process_with_input(&[8]);
        assert_eq!(0, m.value_at(9));
    }
    #[test]
    fn test_instruction() {
        let data = vec![1002, 4, 3, 4, 33];
        /*
                ABCDE
                 1002

                DE - two-digit opcode,      02 == opcode 2
                C - mode of 1st parameter,  0 == position mode
                B - mode of 2nd parameter,  1 == immediate mode
                A - mode of 3rd parameter,  0 == position mode,
                                                omitted due to being a leading zero
        */

        let m = Machine::new(&data);
        let instruction = m.instruction(0);
        assert_eq!(
            instruction,
            OpCode::Multiplication(Mode::Position(4), Mode::Immediate(3), Mode::Position(4))
        );
    }
    #[test]
    fn test_defaults() {
        let data = vec![1, 4, 3, 4, 33];
        /*
                ABCDE
                 1002

                DE - two-digit opcode,      02 == opcode 2
                C - mode of 1st parameter,  0 == position mode
                B - mode of 2nd parameter,  1 == immediate mode
                A - mode of 3rd parameter,  0 == position mode,
                                                omitted due to being a leading zero
        */

        let m = Machine::new(&data);
        let instruction = m.instruction(0);
        assert_eq!(
            instruction,
            OpCode::Addition(Mode::Position(4), Mode::Position(3), Mode::Position(4))
        );
    }
    #[test]
    fn test_run() {
        let data = vec![1002, 4, 3, 4, 33];
        let mut m = Machine::new(&data);
        m.process();
        assert_eq!(MachineState::Completed, m.state);
        assert_eq!(99, m.value_at(4));
    }
}
